# Research
서비스 내 사용자 인증(인증 관련 토큰, 해싱) = **"서버 인증"**

[*참고자료*](https://tansfil.tistory.com/58)

## 인증이 필요한 이유
- **프론트엔드 관점, "인증"이란**
    - 사용자의 로그인, 회원가입과 같은 도입 부분
    <br>
- **서버사이드 관점, "인증"이란**
    - 모든 API 요청에 대해 사용자를 확인하는 작업
    - ~~사용자가 누군지 알아야 그에 맞는 데이터를 보내주고 등등... 당연~~
    <br>
- ~~인증에 앞서~~**HTTP 요청**
    - 현재 모바일이나 웹 서비스에서 가장 많이 쓰이는 통신 방식
    - **구조**
        - |요청 라인|
          |----|
          |헤더|
          |공백|
          |바디|
    - 일반적으로 헤더와 바디 두가지로 구성되며, 공백은 헤더와 바디를 구분짓는 역할을 합니다.
    - 여기서 헤더에는 기본적으로 요청에 대한 정보들이 들어갑니다. 바디에는 서버로 보내야할 데이터가 들어가게 됩니다.
    <br>   
  
## 인증 방식
1. **계정정보를 요청 헤더에 넣는 방식**
    - 가장 보안이 낮은 방식으로 계정정보를 HTTP 요청에 담아 보내는 방식
    - ~~HTTP 방식은 요청이 암호화 되지 않아 보안에 아주 취약~~
    - **장점**
        - 인증을 테스트 할 때 빠르게 시도해볼 수 있다.
    - **단점**
        - 보안에 매우 취약하다.
        - 서버에서는 신호가 올때마다 Id,Pw를 통해 유저가 맞는지 인증해야 한다. 이는 비효율적이다.  
          
          
2. **Session / Cookie 방식**
![SessCook](/docs/images/Session%20and%20Cookie.png)
    - **장점**
        - 쿠키가 담긴 HTTP 요청이 도중에 노출되더라도 쿠키 자체(세션 ID)는 유의미한 값을 갖고있지 않음.
        - 사용자는 고유의 ID값을 발급받게 됩니다. ~~더 효율적인 Index~~ 그렇게 되면 서버에서는 쿠키 값을 받았을 때 일일이 회원정보를 확인할 필요 없이 바로 어떤 회원인지를 확인할 수 있어 서버의 자원에 접근하기 용이함.
    - **단점**
        - 탈취하면 그 사용자가 서버로부터 받는 정보를 그대로 받을 수 있음.
        - **(해결책)** HTTPS(요청 자체가 암호화)를 사용해 요청 자체를 탈취해도 안의 정보를 읽기 힘들게 한다. OR 세션에 유효시간을 넣어준다.
        - 추가적인 저장공간을 필요로 하게 된다.  
          
          
3. **토큰 기반 인증 방식 (ft. JWT)**
![jwt](/docs/images/jwt.png)  
    - 토큰을 만들기 위해서는 크게 3가지, **Header**, **Payload**, **Verify Signature**가 필요.
    - 최종적인 결과 : Encoded Header + "." + Encoded Payload + "." + Verify Signature  
      
![jwt2](/docs/images/jwt2.png)
    - **장점**
        - 간편합니다. 세션/쿠키는 별도의 저장소의 관리가 필요합니다. 그러나 JWT는 발급한 후 검증만 하면 되기 때문에 추가 저장소가 필요 없습니다.
        - 확장성이 뛰어납니다. 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능합니다. 예를 들어 Facebook 로그인, Google 로그인 등은 모두 토큰을 기반으로 인증을 합니다.
    - **단점**
        - 이미 발급된 JWT에 대해서는 돌이킬 수 없습니다. 세션/쿠키의 경우 만일 쿠키가 악의적으로 이용된다면, 해당하는 세션을 지워버리면 됩니다. 하지만 JWT는 한 번 발급되면 유효기간이 완료될 때 까지는 계속 사용이 가능합니다.
        - Payload 정보가 제한적입니다. 위에서 언급했다시피 Payload는 따로 암호화되지 않기 때문에 디코딩하면 누구나 정보를 확인할 수 있습니다.
        - JWT의 길이입니다. 세션/쿠키 방식에 비해 JWT의 길이는 깁니다. 따라서 인증이 필요한 요청이 많아질 수록 서버의 자원낭비가 발생하게 됩니다. 
    
